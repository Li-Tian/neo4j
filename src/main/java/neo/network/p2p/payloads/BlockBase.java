package neo.network.p2p.payloads;


import com.google.gson.JsonObject;

import java.io.ByteArrayOutputStream;

import neo.UInt160;
import neo.UInt256;
import neo.cryptography.Crypto;
import neo.csharp.Uint;
import neo.csharp.Ulong;
import neo.csharp.io.BinaryReader;
import neo.csharp.io.BinaryWriter;
import neo.exception.InvalidOperationException;
import neo.log.tr.TR;
import neo.persistence.Snapshot;

/**
 * Block base class
 */
public abstract class BlockBase implements IVerifiable {

    /**
     * Block version
     */
    public Uint version;

    /**
     * Previous block hash
     */
    public UInt256 prevHash;

    /**
     * Merkle root
     */
    public UInt256 merkleRoot;

    /**
     * Timestamp
     */
    public Uint timestamp;

    /**
     * Block height
     */
    public Uint index;

    /**
     * Consensus additional data, the default is block nonce. a pseudo-random number generated by
     * the speaker when the block is released
     */
    public Ulong consensusData;

    /**
     * Next block consensus address，two-thirds multiparty signed contract address of consensus
     * nodes
     */
    public UInt160 nextConsensus;

    /**
     * Witness
     */
    public Witness witness;

    private UInt256 hash = null;

    /**
     * Block hash
     *
     * @return UInt256
     */
    public UInt256 hash() {
        if (hash == null) {
            hash = new UInt256(Crypto.Default.hash256(this.getMessage()));
        }
        return hash;
    }


    /**
     * Get Witness list
     *
     * @return Witness[]
     */
    @Override
    public Witness[] getWitnesses() {
        return new Witness[]{witness};
    }

    /**
     * Set Witness list
     */
    @Override
    public void setWitnesses(Witness[] witnesses) {
        if (witnesses.length != 1) throw new IllegalArgumentException();
        this.witness = witnesses[0];
    }


    /**
     * the size of storage
     */
    @Override
    public int size() {
        // C# code  Size => sizeof(uint) + PrevHash.Size + MerkleRoot.Size + sizeof(uint) + sizeof(uint) + sizeof(ulong) + NextConsensus.Size + 1 + Witness.Size;
        // 4 + 32 + 32 + 4 + 4 + 8 + 20 + 1 + （1+2+1+2） =105 + 6 => 111
        return Uint.BYTES + prevHash.size() + merkleRoot.size() + Uint.BYTES
                + Uint.BYTES + Ulong.BYTES + nextConsensus.size() + 1 + witness.size();
    }

    /**
     * Deserialize method
     *
     * @param reader BinaryReader
     */
    @Override
    public void deserialize(BinaryReader reader) {
        this.deserializeUnsigned(reader);
        if (reader.readByte() != 1) throw new IllegalArgumentException();
        witness = reader.readSerializable(() -> new Witness());
    }


    /**
     * Deserialize method（Block header）
     *
     * @param reader BinaryReader
     */
    @Override
    public void deserializeUnsigned(BinaryReader reader) {
        version = reader.readUint();
        prevHash = reader.readSerializable(() -> new UInt256());
        merkleRoot = reader.readSerializable(() -> new UInt256());
        timestamp = reader.readUint();
        index = reader.readUint();
        consensusData = reader.readUlong();
        nextConsensus = reader.readSerializable(() -> new UInt160());
    }

    /**
     * Serialize
     *
     * <p>fields</p>
     * <ul>
     * <li>Version: Version</li>
     * <li>PrevHash: Previous block hash</li>
     * <li>MerkleRoot: Merkle root</li>
     * <li>Timestamp: Timestamp</li>
     * <li>Index: Block height</li>
     * <li>ConsensusData: Consensus Data.The default is block nonce.A pseudo-random number
     * generated by the speaker when the block is released</li>
     * <li>NextConsensus: Next block consensus address</li>
     * </ul>
     *
     * @param writer BinaryWriter
     */
    @Override
    public void serialize(BinaryWriter writer) {
        this.serializeUnsigned(writer);
        writer.writeByte((byte) 1);
        writer.writeSerializable(witness);
    }

    /**
     * Serialize method（block header）
     *
     * @param writer BinaryWriter
     */
    @Override
    public void serializeUnsigned(BinaryWriter writer) {
        writer.writeUint(version);
        writer.writeSerializable(prevHash);
        writer.writeSerializable(merkleRoot);
        writer.writeUint(timestamp);
        writer.writeUint(index);
        writer.writeUlong(consensusData);
        writer.writeSerializable(nextConsensus);
    }

    /**
     * Get the script hash collection for validation. Actually, it is two-thirds of the multi-party
     * signed contract address of the current block consensus node.
     *
     * @param snapshot Database Snapshot
     * @return script hash collection
     */
    @Override
    public UInt160[] getScriptHashesForVerifying(Snapshot snapshot) {
        if (prevHash == UInt256.Zero) {
            return new UInt160[]{witness.scriptHash()};
        }

        Header prevHeader = snapshot.getHeader(prevHash);
        if (prevHeader == null) {
            throw new InvalidOperationException();
        }
        return new UInt160[]{prevHeader.nextConsensus};
        // C# code
        //        Header prev_header = snapshot.GetHeader(PrevHash);
        //        if (prev_header == null) throw new InvalidOperationException();
        //        return new UInt160[]{prev_header.NextConsensus};
    }

    /**
     * Get hash data
     *
     * @return hash data
     */
    @Override
    public byte[] getMessage() {
        return this.getHashData();
    }

    /**
     * get the serialized data for the specified object
     *
     * @return serialized data
     */
    @Override
    public byte[] getHashData() {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        BinaryWriter writer = new BinaryWriter(outputStream);
        serializeUnsigned(writer);
        writer.flush();
        return outputStream.toByteArray();
    }

    /**
     * Convert to a JObject object
     *
     * @return JObject object
     */
    public JsonObject toJson() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("hash", hash().toString());
        jsonObject.addProperty("size", size());
        jsonObject.addProperty("version", version);
        jsonObject.addProperty("previousblockhash", prevHash.toString());
        jsonObject.addProperty("merkleroot", merkleRoot.toString());
        jsonObject.addProperty("time", timestamp);
        jsonObject.addProperty("index", index);
        jsonObject.addProperty("nonce", consensusData.toString());
        jsonObject.addProperty("nextconsensus", nextConsensus.toString());
        jsonObject.add("script", witness.toJson());
        return jsonObject;
    }

    /**
     * Verify the block based on the current block snapshot
     *
     * @param snapshot block snapshot
     * @return If the following four conditions are met, the verification result is false.<br/>
     * <ul>
     * <li>1) If the previous block does not exist</li>
     * <li>2) If the previous block height plus 1 is not equal to the current block height</li>
     * <li>3) If the previous block timestamp is greater than or equal to the current block
     * timestamp</li>
     * <li>4) If witness verification fails</li>
     * </ul>
     */
    public boolean verify(Snapshot snapshot) {
        Header prevHeader = snapshot.getHeader(prevHash);
        if (prevHeader == null) {
            return false;
        }
        if (!prevHeader.index.add(new Uint(1)).equals(index)) {
            return false;
        }
        if (prevHeader.timestamp.compareTo(timestamp) >= 0) {
            return false;
        }
        if (!IVerifiable.verifyWitnesses(this, snapshot)) {
            return false;
        }
        return true;
    }

}
